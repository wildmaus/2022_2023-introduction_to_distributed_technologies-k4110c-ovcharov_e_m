# Why pancake farming contract is brilliant.

### введение
Фермы панкейксвапа позволяют вам получать дополнительный доход в виде токенов cake за стейкинг lp токенов. Но речь в этой статье пойдет не о том как сделать это эффективнее. В данной статье я разберу смарт-контакт фарминга и матетамику стоящую за ним. За время работы разработчиком смарт-контрактов я успел написать разные вариации стейкинга, но глобально их можно разделить на 2 типа. 

Первый - каждый пользователь получает определенный процент награды, начилсяемый либо с учетом реинвестирования, либо без него. Награды чаще всего выплачиваются из определенного пула, а пользователи выбирают время, на которое они стейкают токены (чем дольше тем больший процент они будут получать).

Второй - пользователь получает часть награды пропорционально доле своего стейка от общего числа застейканных токенов. Каждый промежуток времени (1 секунда, 1 блок, 1 день и т.д) происходит распределение определенного числа токенов. Фарминг панкейка относится как раз к второму типу.

<!-- 
TODO check mistakes 
--> 
### математическая формула расрпеделения
Рассмотрим формулу начисления токенов по узаканным правилам. Для начала нам нужно знать какую часть от общего имеет пользователь.
`userPercent = userStakeAmount / totalStakeAmount`
Получается пользователь при каждом распределении награды должен получать эту часть от распределяемого количества токенов.
`userRewardStepAmount = rewardPerStep * userPercent`
Следовательно на момент вывода пользователь должен получить количество токенов равное сумме распределенных ему наград на каждом шаге распределения
`userRewardAmount = sum(userRewardStepAmount[i])`, где `i` - шаги распределения награды
следовательно раскрывая формулу получаем
`userRewardAmount = sum(rewardPerStep[i] * userStakeAmount / totalStakeAmount[i])`
Таким образом для начисления награды пользователям нужно проходить по каждому циклом и вычислять их процент на текущий момент. Сответственно если у нас 10 пользователей, то это еще приемлимые цифры, однако с ростом числа пользователей это число будет расти и в итоге только на поддержание системы будут уходить огромные суммы.

### как панкейк изменил ее
Для исключения цикла и сведения расчета награды к константному времени панкейки изменили формулу для расчета награды.
Рассмотрим последнюю формулу подробнее. Из переменных у нас `totalStakeAmount[i]` т.к. другие пользователи могут вносить и выводить токены и `rewardPerStep`. Будем рассматривать userStakeAmount как константу, потому что при любом ее изменении начисленная награда может быть выведена/сохранена (конец текущего промежутка), а дальше начисления будут проводиться уже на измененный `userStakeAmount` (начало нового промежутка).
Следовательно можно вынести это слагаемое за сумму
`userRewardAmount = userStakeAmount * sum(rewardPerStep[i] / totalStakeAmount[i])`

Вынесем сумму из указанной выше формулы в отдельную переменную - `accCakePerShare`. Она будет сохранять сумму всех `rewardPerStep[i] / totalStakeAmount[i]`, с самого первого шага распределения и до последнего. Тогда между любыми изменениями rewardPerStep и totalStakeAmount это слагаемое будет константой. То есть пусть n cекунд никто не вносит и не выводит токены, а rewardPerStep вообще не изменяется. Тогда за эти n секунд будет начисленно `n * rewardPerStep / totalStakeAmount`. Таким образом за счет умножения 3х слогаемых (константная операция) происходит начисление наградных токенов всем участникам стейкинга! 
Но осталось решить еще одну проблему. Т.к в `accCakePerShare` сохраняются все суммы от начала распределения, то нужно дополнительно исключить часть токенов, в распределении которых пользователь не участвовал. Для этого при изменении стейка пользователя, мы записываем значение `accRewardPerShare` на момент этого события и позже начисляем пользователю только часть равную `userStakeAmount * (accRewardPerShere[end] - accRewardPerShere[start]) = userStakeAmount * sum(rewardPerStep[i] / totalStakeAmount[i])`, где `i = (start : end]`
Вот таким образом панкейки свели начисление награды пользователю до константной сложности! : fire :

### вырезки из реализации
рассмотрим контракт реализации приведенных выше формул

Для начала для начисления наград панкейк вводит пулы - разные пулы для разных токенов. Именно в них хранится accCakePerShere, а также таймстемп последнего обновления. Т.к. контракты не умеют работать с дробными числами для сохранения точности и уменьшения погрешностей целочисленной арифметики accRewardPerShere хранит значение описанной выше суммы умноженное на 10^12. 
*В своих контрактах я использовал значения 10^24, чтобы сохранить больше знаков после запятой (uint256 позволяет хранить значения до 10^76 так что нет опасности переполнения).*
```
struct Pool {
    uint256 accCakePerShare;
    uint256 lastUpdateBlock;
    ...
}
```
Для пользователя также есть структура. В ней сохраняется размер стейка, значение `accRewardPerShere * amount` на момент последнего изменения `amount` пользователя (то есть та часть распределенных токенов, в которой пользователь еще не участвовал). В последней версии панкейк добавил возможность бустинга. Пользователь получает больше награды за счет того, что его amount _виртуально_ увеличивается в несколько раз (в зависимости от значения множителя). Таким образом стейк пользователя составляет большую часть от общего чем без бустинга следовательно пользователь получает больше награды. При любом изменении `amount` пользователя ему отправляется полученное число токенов, а rewardDebt обновляется до этого момента (т.к. за предыдущий период пользователь уже вывел награду).
*В своих контрактах я добавлял в структуру пользователя поле `accReward` для сохранения уже полученной награды пользователем при изменении его `amount`, т.к. в них была предусмотрена блокировка вывода на определенный период.*
```
struct UserInfo {
    uint256 amount;
    uint256 rewardDebt;
    uint256 boostMultiplier;
}
```
Перед каждым изменении размера стейка каким либо пользователем вызывается метод `updatePool`. Он обновляет `accRewardPerShare` добавляя в него `(block.number - lastUpdateBlock) * rewardPerStep / totalStakeAmount`, то есть обновляя сумму до актуального состояния. После чего пользоватю рассчитывается накопленная до изменения стейка награда -  `amount * accRewardPerShere - rewardDebt` (и она сразу отправляется пользователю в случае панкейка). Затем обновляются `rewardDebt` и `totalStakeAmount`, а пользователь получает дальнейшие награды уже на измененный `amount`.

<!--
TODO think about this part 
### интересные замечания
Как вы могли понять из описания выше (а если нет, то сейчас я проясню этот момент) - есть только один способ применения множителя к данной формуле (если мы не хотим выплачивать больше чем rewardPerStep). Этот множитель должен применяться к userStakeAmount _виртуально_ увеличивая его. Вернемся к формуле
`userRewardAmount = userStakeAmount * sum(rewardPerStep[i] / totalStakeAmount[i]), i = (start:end]`
При добавлении множителя на размер стейка (`userStakeAmountBoost = userStakeAmount * boostMultiplier`) формула остается почти неизменной и мы также можем вынести сумму в отдельную переменную accRewardPerShare, учитывая что `totalStakeAmount` рассчитывается как сумма увеличенных стейков
`userRewardAmount = userStakeAmountBoost * sum(rewardPerStep[i] / totalStakeAmountBoost[i]), i = (start:end]`
Однако если мы знахотим добавить множитель на любую другую переменную - в сумме мы будем выплачивать больше чем `rewardPerStep * numberOfSteps`, что может привести к проблемам (пользователи не смогут вывести награду т.к. она превышает доступный баланс токенов). -->
### summary
фарминг панкейка один из популярных паттернов проектирвоания смарт-контрактов и это не удивительно, учитывая как он свел сложность рассчетов награды в цикле неопределенной длинны к константной!